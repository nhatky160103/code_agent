# Code Agent - Plain-English Overview

## Purpose

Code Agent is an automated AI workflow that collaborates on software tasks. Instead of handling every step manually, you describe the job (analyze, fix, refactor, test, document) and a set of specialized agents work together to produce a complete result.

## The Agent Team

| Agent | Responsibility | Typical Output |
|-------|----------------|----------------|
| Code Reader | Scans the repository, identifies technologies, and summarizes structure. | Codebase report, file inventory, tech stack description. |
| Bug Fixer | Finds defects, explains issues, and proposes patches. | List of bugs plus patched code snippets. |
| Refactorer | Improves readability, structure, and style without altering behavior. | Refactored code and rationale. |
| Tester | Generates pytest suites and (optionally) runs them. | `test_code` plus pytest logs if `action="run"`. |
| PR Generator | Crafts commit messages and pull-request descriptions. | Ready-to-copy commit + PR summary. |
| Architect | Suggests high-level structure and best practices. | Architecture recommendations and to-do lists. |

## How Requests Flow

1. **Task submission** - e.g., `python main.py "analyze codebase, fix bugs, refactor, write tests"`.
2. **Router decision** - LangGraph routes the shared state to the next required agent.
3. **Execution** - each agent reads from the shared `AgentState`, performs its work with an LLM, and writes back new context/results.
4. **Aggregation** - once all required agents complete, the workflow returns a consolidated dictionary that includes analyses, code patches, tests, and documentation.

```
Task -> Router -> Code Reader -> Bug Fixer -> Refactorer -> Tester -> PR Generator (+ Architect when requested) -> Results
```

## Practical Example

You need to improve a Python service:

1. Run `python main.py "analyze codebase, find bugs, fix them, refactor, write tests, and generate PR"`.
2. Code Agent:
   - Scans the repo and summarizes structure.
   - Highlights multiple bugs, explains each, and shows fixed snippets.
   - Refactors long functions.
   - Generates pytest suites (and can execute them if `context.action="run"`).
   - Produces a commit message and PR description ready for GitHub.
3. You copy the artifacts to your editor, run tests locally if needed, and push.

## When to Use Code Agent

**Great fit when you:**
- Need rapid onboarding for a medium/large repository.
- Want help finding issues spread across multiple files.
- Plan to refactor legacy code or enforce style consistently.
- Want autogenerated tests plus documentation for a PR.

**Not ideal when you:**
- Cannot share the code with any external service or LLM.
- Need full manual control over every change.
- Have a trivial script (faster to edit by hand).

## Key Ideas to Remember

- The workflow is deterministic at the orchestration level, but each agent calls an LLM for reasoning and code.
- Shared state guarantees that downstream agents can reuse upstream context without repeated analysis.
- You can extend the system by adding new agents, tweaking routing rules, or integrating deployment hooks (GitHub CLI/API, CI, etc.).

## Getting Started Quickly

```bash
python main.py "analyze codebase"
python main.py "find and fix bugs"
python main.py "refactor code and write tests"
python main.py "analyze, fix bugs, refactor, test, generate PR"
```

These commands return structured JSON output so you can copy the generated code, test suites, and documentation directly into your project.

